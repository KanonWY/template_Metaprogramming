# template_Metaprogramming
### 1、基本概念
#### 模板类型
- 函数模板    
- 类模板  
- 可变参模板  
- 别名模板  

#### 模板参数类型
- 类型模板参数
- 非类型模板参数
- 双重模板参数

#### 特化
模板可以使用替换来实现特化，特化是为了实现优化和避免代码膨胀。
- 偏特化
- 全特化

#### 模板实例化
编译器通过模板生成代码的过程。
- 隐式实例化  
当编译器检测到在代码中使用了模板，就会发生隐式实例化。

- 显式实例化  
显式的告诉编译器要创建模板的哪些实例化方法，即使这些实例化没有在代码中使用。

### 2、发展
- C++11：
可变参数模板、模板别名、外部模板、类型特征。
- C++14：
变量模板
- C++17：
折叠表达式、模板参数、非类型模板参数auto、类模板的参数推导
- C++20：
模板lambda、字符串字面量作为模板参数、约束、概念

### 3、基本使用

#### 基本认识

非成员函数和类成员函数可以是模板函数，但是虚函数不能是模板函数。

Most of the uses of function templates involve the automatic deduction of types.

对于类模板，实例化类模板会实例化所有的数据成员，但是其方法只有在使用的时候才会实例化。

#### 实例化

模板只是蓝图，编译器在遇到模板的时候，会根据实际情况创建实际代码。从模板声明中为函数、类或者变量创建定义的行为称为模板实例化。

可以是显式的，也可以是隐式的。

其中显式实例化还可以分为：显式实例化定义和显式实例化声明。

显式实例化定义可以出现在程序中的任何地方，但不能出现在所引用的模板定义之后。

显式实例化声明 (C++11 中提供) 可以告诉编译器模板实例化的定义在不同的翻译单元中，并且 不应该生成新的定义。语法与显式实例化定义相同，除了关键字 extern 可用在声明前:

#### 特化注意事项

特化运行我们为不同的类型参数编写不同的模板函数。常分为两类：1、Explicit specialization。2、部分特化

显式特化必须出现在主模板声明之后，不需要在显式特化之前对主模板进行定义。

- 全特化/显式特化



- 偏特化

偏特化发生在特化一个主模板但只指定一些模板参数时，所以偏特化同时具有模板形参列表 (跟在模板关键字后面) 和模板实参列表 (跟在模板名称后面)，只有类可以偏特化。

当定义主模板的特化时注意事项：

1、偏特化的模板参数列表中的参数不能有默认值。

2、模板参数列表表示模板参数列表中的顺序，该顺序仅针对偏特化。偏特化的模板参数列表不能与模板参数列表所表示的模板参数列表相同。

### 代码组织形式

只要是模板，就要像宏一样写在同一个文件中，如果是特例，就要像普通函数（或者类）一样，声明写在头文件中，实现写在源文件中。

[特化代码组织形式](https://blog.csdn.net/fl2011sx/article/details/100588160)

[c++ header-only](https://v1otusc.github.io/2021/05/28/C++-inline-hpp/)



### ppt

[ppt1](https://netcan.github.io/presentation/metaprogramming/#/_%E8%AE%AE%E7%A8%8B)















