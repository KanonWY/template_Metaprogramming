# template_Metaprogramming
### 1、基本概念
#### 模板类型
- 函数模板    
- 类模板  
- 可变参模板  
- 别名模板  

#### 模板参数类型
- 类型模板参数
- 非类型模板参数
- 双重模板参数

#### 特化
模板可以使用替换来实现特化，特化是为了实现优化和避免代码膨胀。
- 偏特化
- 全特化

#### 模板实例化
编译器通过模板生成代码的过程。
- 隐式实例化  
当编译器检测到在代码中使用了模板，就会发生隐式实例化。

- 显式实例化  
显式的告诉编译器要创建模板的哪些实例化方法，即使这些实例化没有在代码中使用。

### 2、发展
- C++11：
可变参数模板、模板别名、外部模板、类型特征。
- C++14：
变量模板
- C++17：
折叠表达式、模板参数、非类型模板参数auto、类模板的参数推导
- C++20：
模板lambda、字符串字面量作为模板参数、约束、概念

### 3、基本使用

#### 基本认识

非成员函数和类成员函数可以是模板函数，但是虚函数不能是模板函数。

Most of the uses of function templates involve the automatic deduction of types.

对于类模板，实例化类模板会实例化所有的数据成员，但是其方法只有在使用的时候才会实例化。

#### 实例化

模板只是蓝图，编译器在遇到模板的时候，会根据实际情况创建实际代码。从模板声明中为函数、类或者变量创建定义的行为称为模板实例化。

可以是显式的，也可以是隐式的。

其中显式实例化还可以分为：显式实例化定义和显式实例化声明。

显式实例化定义可以出现在程序中的任何地方，但不能出现在所引用的模板定义之后。

显式实例化声明 (C++11 中提供) 可以告诉编译器模板实例化的定义在不同的翻译单元中，并且 不应该生成新的定义。语法与显式实例化定义相同，除了关键字 extern 可用在声明前:

#### 特化注意事项

特化运行我们为不同的类型参数编写不同的模板函数。常分为两类：1、Explicit specialization。2、























